# ğŸ“Š QuantTrade ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹… ê°€ì´ë“œ

## ğŸ“‹ ê°œìš”

QuantTrade í”Œë«í¼ì˜ ì•ˆì •ì ì¸ ìš´ì˜ì„ ìœ„í•œ í¬ê´„ì ì¸ ëª¨ë‹ˆí„°ë§, ë¡œê¹…, ì—ëŸ¬ ì¶”ì  ì‹œìŠ¤í…œ êµ¬ì¶• ê°€ì´ë“œì…ë‹ˆë‹¤.

### ğŸ¯ ëª¨ë‹ˆí„°ë§ ëª©í‘œ
- âœ… **ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ ìƒíƒœ ì¶”ì **: í”Œë«í¼ ê°€ë™ë¥  99.9% ì´ìƒ ìœ ì§€
- âœ… **ì„±ëŠ¥ ìµœì í™”**: ì‘ë‹µ ì‹œê°„ 500ms ì´í•˜ ìœ ì§€
- âœ… **ì—ëŸ¬ ì¡°ê¸° ê°ì§€**: ë¬¸ì œ ë°œìƒ ì‹œ ì¦‰ì‹œ ì•Œë¦¼
- âœ… **ì‚¬ìš©ì ê²½í—˜ ëª¨ë‹ˆí„°ë§**: ì‹¤ì œ ì‚¬ìš©ì ê²½í—˜ ì¶”ì 
- âœ… **ë³´ì•ˆ ì´ë²¤íŠ¸ ê°ì§€**: ë¹„ì •ìƒì ì¸ í™œë™ ì‹¤ì‹œê°„ ê°ì§€

---

## ğŸ—ï¸ ëª¨ë‹ˆí„°ë§ ì•„í‚¤í…ì²˜

### ğŸ“Š ì „ì²´ ëª¨ë‹ˆí„°ë§ ìŠ¤íƒ
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   Vercel    â”‚ â”‚   Sentry    â”‚ â”‚   Custom    â”‚           â”‚
â”‚  â”‚ Analytics   â”‚ â”‚   Error     â”‚ â”‚ Dashboard   â”‚           â”‚
â”‚  â”‚             â”‚ â”‚  Tracking   â”‚ â”‚             â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ë°ì´í„° ìˆ˜ì§‘ ê³„ì¸µ                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  Frontend   â”‚ â”‚   Backend   â”‚ â”‚  Database   â”‚           â”‚
â”‚  â”‚   Metrics   â”‚ â”‚    Logs     â”‚ â”‚   Metrics   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    QuantTrade Platform                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   Next.js   â”‚ â”‚   API       â”‚ â”‚  Supabase   â”‚           â”‚
â”‚  â”‚   Frontend  â”‚ â”‚   Routes    â”‚ â”‚  Database   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ˆ 1. Vercel ëª¨ë‹ˆí„°ë§

### 1.1 Vercel Analytics ì„¤ì •

#### ì„¤ì¹˜ ë° ì„¤ì •
```bash
# Vercel Analytics ì„¤ì¹˜
npm install @vercel/analytics
```

```typescript
// src/app/layout.tsx
import { Analytics } from '@vercel/analytics/react';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ko">
      <body>
        {children}
        <Analytics />
      </body>
    </html>
  );
}
```

#### ì»¤ìŠ¤í…€ ì´ë²¤íŠ¸ ì¶”ì 
```typescript
// src/lib/analytics.ts
import { track } from '@vercel/analytics';

export const trackEvent = {
  // ê±°ë˜ ê´€ë ¨ ì´ë²¤íŠ¸
  tradeCreated: (data: {
    amount: number;
    direction: 'up' | 'down';
    duration: number;
  }) => {
    track('trade_created', {
      amount: data.amount,
      direction: data.direction,
      duration: data.duration,
    });
  },

  tradeCompleted: (data: {
    result: 'win' | 'lose';
    profit: number;
    duration: number;
  }) => {
    track('trade_completed', {
      result: data.result,
      profit: data.profit,
      duration: data.duration,
    });
  },

  // ì‚¬ìš©ì í–‰ë™ ì´ë²¤íŠ¸
  userLogin: (method: 'email' | 'social') => {
    track('user_login', { method });
  },

  pageView: (page: string) => {
    track('page_view', { page });
  },

  // ì—ëŸ¬ ì´ë²¤íŠ¸
  apiError: (endpoint: string, status: number) => {
    track('api_error', { endpoint, status });
  }
};
```

### 1.2 Vercel í•¨ìˆ˜ ëª¨ë‹ˆí„°ë§

#### í•¨ìˆ˜ ì„±ëŠ¥ ì¶”ì 
```typescript
// src/lib/performance.ts
export class PerformanceMonitor {
  private static instance: PerformanceMonitor;
  
  static getInstance(): PerformanceMonitor {
    if (!PerformanceMonitor.instance) {
      PerformanceMonitor.instance = new PerformanceMonitor();
    }
    return PerformanceMonitor.instance;
  }

  // API ì‘ë‹µ ì‹œê°„ ì¸¡ì •
  async measureApiCall<T>(
    name: string,
    apiCall: () => Promise<T>
  ): Promise<T> {
    const start = Date.now();
    
    try {
      const result = await apiCall();
      const duration = Date.now() - start;
      
      // ì„±ëŠ¥ ë¡œê·¸
      console.log(JSON.stringify({
        type: 'performance',
        api: name,
        duration,
        status: 'success',
        timestamp: new Date().toISOString()
      }));
      
      return result;
    } catch (error) {
      const duration = Date.now() - start;
      
      console.error(JSON.stringify({
        type: 'performance',
        api: name,
        duration,
        status: 'error',
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString()
      }));
      
      throw error;
    }
  }
}
```

---

## ğŸš¨ 2. Sentry ì—ëŸ¬ ì¶”ì 

### 2.1 Sentry ì„¤ì •

#### ì„¤ì¹˜ ë° ì´ˆê¸° ì„¤ì •
```bash
# Sentry ì„¤ì¹˜
npm install @sentry/nextjs
```

```javascript
// sentry.client.config.js
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  
  // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
  tracesSampleRate: 1.0,
  
  // ì„¸ì…˜ ì¬ìƒ
  replaysSessionSampleRate: 0.1,
  replaysOnErrorSampleRate: 1.0,
  
  // ì—ëŸ¬ í•„í„°ë§
  beforeSend(event, hint) {
    // ê°œë°œ í™˜ê²½ì—ì„œëŠ” ì½˜ì†”ì—ë„ ì¶œë ¥
    if (process.env.NODE_ENV === 'development') {
      console.error('Sentry Error:', hint.originalException);
    }
    return event;
  },
  
  // ì‚¬ìš©ì ì»¨í…ìŠ¤íŠ¸ ì„¤ì •
  initialScope: {
    tags: {
      component: 'quanttrade-frontend'
    }
  }
});
```

```javascript
// sentry.server.config.js
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 1.0,
  
  // ì„œë²„ ì‚¬ì´ë“œ ì—ëŸ¬ ì²˜ë¦¬
  beforeSend(event, hint) {
    // ë¯¼ê°í•œ ì •ë³´ ì œê±°
    if (event.request) {
      delete event.request.headers?.authorization;
      delete event.request.headers?.cookie;
    }
    return event;
  }
});
```

### 2.2 ì»¤ìŠ¤í…€ ì—ëŸ¬ ì¶”ì 

#### ì—ëŸ¬ ë˜í¼ í´ë˜ìŠ¤
```typescript
// src/lib/errorTracking.ts
import * as Sentry from '@sentry/nextjs';

export class ErrorTracker {
  // API ì—ëŸ¬ ì¶”ì 
  static trackApiError(
    error: Error,
    context: {
      endpoint: string;
      method: string;
      userId?: string;
      requestData?: any;
    }
  ) {
    Sentry.withScope((scope) => {
      scope.setTag('error_type', 'api_error');
      scope.setContext('api_context', {
        endpoint: context.endpoint,
        method: context.method,
        userId: context.userId
      });
      
      // ë¯¼ê°í•œ ë°ì´í„° ì œê±°
      if (context.requestData) {
        const sanitizedData = { ...context.requestData };
        delete sanitizedData.password;
        delete sanitizedData.token;
        scope.setContext('request_data', sanitizedData);
      }
      
      Sentry.captureException(error);
    });
  }

  // ê±°ë˜ ì—ëŸ¬ ì¶”ì 
  static trackTradeError(
    error: Error,
    tradeData: {
      tradeId?: string;
      userId: string;
      amount: number;
      type: string;
    }
  ) {
    Sentry.withScope((scope) => {
      scope.setTag('error_type', 'trade_error');
      scope.setUser({ id: tradeData.userId });
      scope.setContext('trade_context', {
        tradeId: tradeData.tradeId,
        amount: tradeData.amount,
        type: tradeData.type
      });
      
      Sentry.captureException(error);
    });
  }

  // ì¸ì¦ ì—ëŸ¬ ì¶”ì 
  static trackAuthError(
    error: Error,
    context: {
      action: 'login' | 'register' | 'refresh' | 'logout';
      email?: string;
      userAgent?: string;
    }
  ) {
    Sentry.withScope((scope) => {
      scope.setTag('error_type', 'auth_error');
      scope.setContext('auth_context', {
        action: context.action,
        email: context.email ? context.email.replace(/(.{2}).*(@.*)/, '$1***$2') : undefined,
        userAgent: context.userAgent
      });
      
      Sentry.captureException(error);
    });
  }
}
```

### 2.3 ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

#### íŠ¸ëœì­ì…˜ ì¶”ì 
```typescript
// src/lib/performance.ts
import * as Sentry from '@sentry/nextjs';

export class PerformanceTracker {
  // ê±°ë˜ ìƒì„± ì„±ëŠ¥ ì¶”ì 
  static async trackTradeCreation<T>(
    operation: () => Promise<T>
  ): Promise<T> {
    return await Sentry.startSpan(
      {
        name: 'trade_creation',
        op: 'trade.create'
      },
      async (span) => {
        try {
          const result = await operation();
          span?.setStatus({ code: 2, message: 'ok' });
          return result;
        } catch (error) {
          span?.setStatus({ code: 2, message: 'internal_error' });
          throw error;
        }
      }
    );
  }

  // ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ì„±ëŠ¥ ì¶”ì 
  static async trackDatabaseQuery<T>(
    queryName: string,
    operation: () => Promise<T>
  ): Promise<T> {
    return await Sentry.startSpan(
      {
        name: `db.query.${queryName}`,
        op: 'db.query'
      },
      async (span) => {
        const start = Date.now();
        
        try {
          const result = await operation();
          const duration = Date.now() - start;
          
          span?.setData('duration', duration);
          span?.setStatus({ code: 2, message: 'ok' });
          
          return result;
        } catch (error) {
          span?.setStatus({ code: 2, message: 'internal_error' });
          throw error;
        }
      }
    );
  }
}
```

---

## ğŸ“ 3. êµ¬ì¡°í™”ëœ ë¡œê¹… ì‹œìŠ¤í…œ

### 3.1 ë¡œê±° í´ë˜ìŠ¤ êµ¬í˜„

```typescript
// src/lib/logger.ts
export enum LogLevel {
  ERROR = 0,
  WARN = 1,
  INFO = 2,
  DEBUG = 3
}

export interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: string;
  userId?: string;
  tradeId?: string;
  sessionId?: string;
  metadata?: Record<string, any>;
  error?: {
    name: string;
    message: string;
    stack?: string;
  };
}

export class Logger {
  private static instance: Logger;
  private logLevel: LogLevel;

  constructor() {
    this.logLevel = process.env.NODE_ENV === 'production' 
      ? LogLevel.INFO 
      : LogLevel.DEBUG;
  }

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  private log(entry: LogEntry): void {
    if (entry.level <= this.logLevel) {
      const logString = JSON.stringify({
        ...entry,
        timestamp: new Date().toISOString()
      });

      switch (entry.level) {
        case LogLevel.ERROR:
          console.error(logString);
          break;
        case LogLevel.WARN:
          console.warn(logString);
          break;
        case LogLevel.INFO:
          console.info(logString);
          break;
        case LogLevel.DEBUG:
          console.debug(logString);
          break;
      }
    }
  }

  // ì—ëŸ¬ ë¡œê·¸
  error(message: string, error?: Error, metadata?: Record<string, any>): void {
    this.log({
      level: LogLevel.ERROR,
      message,
      timestamp: new Date().toISOString(),
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined,
      metadata
    });
  }

  // ê²½ê³  ë¡œê·¸
  warn(message: string, metadata?: Record<string, any>): void {
    this.log({
      level: LogLevel.WARN,
      message,
      timestamp: new Date().toISOString(),
      metadata
    });
  }

  // ì •ë³´ ë¡œê·¸
  info(message: string, metadata?: Record<string, any>): void {
    this.log({
      level: LogLevel.INFO,
      message,
      timestamp: new Date().toISOString(),
      metadata
    });
  }

  // ë””ë²„ê·¸ ë¡œê·¸
  debug(message: string, metadata?: Record<string, any>): void {
    this.log({
      level: LogLevel.DEBUG,
      message,
      timestamp: new Date().toISOString(),
      metadata
    });
  }

  // ê±°ë˜ ê´€ë ¨ ë¡œê·¸
  tradeLog(
    level: LogLevel,
    message: string,
    tradeId: string,
    userId: string,
    metadata?: Record<string, any>
  ): void {
    this.log({
      level,
      message,
      timestamp: new Date().toISOString(),
      tradeId,
      userId,
      metadata
    });
  }

  // ì¸ì¦ ê´€ë ¨ ë¡œê·¸
  authLog(
    level: LogLevel,
    message: string,
    userId?: string,
    sessionId?: string,
    metadata?: Record<string, any>
  ): void {
    this.log({
      level,
      message,
      timestamp: new Date().toISOString(),
      userId,
      sessionId,
      metadata
    });
  }
}

// ì „ì—­ ë¡œê±° ì¸ìŠ¤í„´ìŠ¤
export const logger = Logger.getInstance();
```

### 3.2 API ë¡œê¹… ë¯¸ë“¤ì›¨ì–´

```typescript
// src/lib/middleware/logging.ts
import { NextRequest, NextResponse } from 'next/server';
import { logger } from '@/lib/logger';

export function withLogging(
  handler: (req: NextRequest) => Promise<NextResponse>
) {
  return async (req: NextRequest): Promise<NextResponse> => {
    const start = Date.now();
    const requestId = crypto.randomUUID();
    
    // ìš”ì²­ ë¡œê·¸
    logger.info('API Request', {
      requestId,
      method: req.method,
      url: req.url,
      userAgent: req.headers.get('user-agent'),
      ip: req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip')
    });

    try {
      const response = await handler(req);
      const duration = Date.now() - start;

      // ì„±ê³µ ì‘ë‹µ ë¡œê·¸
      logger.info('API Response', {
        requestId,
        status: response.status,
        duration,
        method: req.method,
        url: req.url
      });

      return response;
    } catch (error) {
      const duration = Date.now() - start;

      // ì—ëŸ¬ ì‘ë‹µ ë¡œê·¸
      logger.error('API Error', error as Error, {
        requestId,
        duration,
        method: req.method,
        url: req.url
      });

      throw error;
    }
  };
}
```

### 3.3 ê±°ë˜ ë¡œê¹…

```typescript
// src/lib/tradeLogger.ts
import { logger } from '@/lib/logger';

export class TradeLogger {
  // ê±°ë˜ ìƒì„± ë¡œê·¸
  static logTradeCreation(data: {
    tradeId: string;
    userId: string;
    amount: number;
    direction: 'up' | 'down';
    duration: number;
    entryPrice: number;
  }): void {
    logger.tradeLog(
      LogLevel.INFO,
      'Trade Created',
      data.tradeId,
      data.userId,
      {
        amount: data.amount,
        direction: data.direction,
        duration: data.duration,
        entryPrice: data.entryPrice,
        action: 'trade_created'
      }
    );
  }

  // ê±°ë˜ ì™„ë£Œ ë¡œê·¸
  static logTradeCompletion(data: {
    tradeId: string;
    userId: string;
    result: 'win' | 'lose';
    profit: number;
    exitPrice: number;
    adminSettings?: any;
  }): void {
    logger.tradeLog(
      LogLevel.INFO,
      'Trade Completed',
      data.tradeId,
      data.userId,
      {
        result: data.result,
        profit: data.profit,
        exitPrice: data.exitPrice,
        adminSettings: data.adminSettings,
        action: 'trade_completed'
      }
    );
  }

  // ê±°ë˜ ì—ëŸ¬ ë¡œê·¸
  static logTradeError(data: {
    tradeId?: string;
    userId: string;
    error: Error;
    context: string;
  }): void {
    logger.tradeLog(
      LogLevel.ERROR,
      `Trade Error: ${data.context}`,
      data.tradeId || 'unknown',
      data.userId,
      {
        error: data.error.message,
        context: data.context,
        action: 'trade_error'
      }
    );
  }
}
```

---

## ğŸ“Š 4. ì»¤ìŠ¤í…€ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

### 4.1 ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

```typescript
// src/lib/metrics.ts
export interface Metric {
  name: string;
  value: number;
  timestamp: number;
  tags?: Record<string, string>;
}

export class MetricsCollector {
  private static instance: MetricsCollector;
  private metrics: Metric[] = [];
  private readonly maxMetrics = 1000;

  static getInstance(): MetricsCollector {
    if (!MetricsCollector.instance) {
      MetricsCollector.instance = new MetricsCollector();
    }
    return MetricsCollector.instance;
  }

  // ë©”íŠ¸ë¦­ ê¸°ë¡
  record(name: string, value: number, tags?: Record<string, string>): void {
    const metric: Metric = {
      name,
      value,
      timestamp: Date.now(),
      tags
    };

    this.metrics.push(metric);

    // ë©”íŠ¸ë¦­ ê°œìˆ˜ ì œí•œ
    if (this.metrics.length > this.maxMetrics) {
      this.metrics = this.metrics.slice(-this.maxMetrics);
    }

    // ì‹¤ì‹œê°„ ë¡œê·¸
    logger.debug('Metric Recorded', { metric });
  }

  // ì¹´ìš´í„° ì¦ê°€
  increment(name: string, tags?: Record<string, string>): void {
    this.record(name, 1, tags);
  }

  // íƒ€ì´ë° ë©”íŠ¸ë¦­
  timing(name: string, duration: number, tags?: Record<string, string>): void {
    this.record(`${name}.duration`, duration, tags);
  }

  // ê²Œì´ì§€ ë©”íŠ¸ë¦­
  gauge(name: string, value: number, tags?: Record<string, string>): void {
    this.record(`${name}.gauge`, value, tags);
  }

  // ë©”íŠ¸ë¦­ ì¡°íšŒ
  getMetrics(name?: string, since?: number): Metric[] {
    let filtered = this.metrics;

    if (name) {
      filtered = filtered.filter(m => m.name === name);
    }

    if (since) {
      filtered = filtered.filter(m => m.timestamp >= since);
    }

    return filtered;
  }

  // ë©”íŠ¸ë¦­ í†µê³„
  getStats(name: string, since?: number): {
    count: number;
    sum: number;
    avg: number;
    min: number;
    max: number;
  } {
    const metrics = this.getMetrics(name, since);
    
    if (metrics.length === 0) {
      return { count: 0, sum: 0, avg: 0, min: 0, max: 0 };
    }

    const values = metrics.map(m => m.value);
    const sum = values.reduce((a, b) => a + b, 0);

    return {
      count: metrics.length,
      sum,
      avg: sum / metrics.length,
      min: Math.min(...values),
      max: Math.max(...values)
    };
  }
}

// ì „ì—­ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°
export const metrics = MetricsCollector.getInstance();
```

### 4.2 í—¬ìŠ¤ ì²´í¬ ì‹œìŠ¤í…œ

```typescript
// src/app/api/health/route.ts
import { NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

interface HealthCheck {
  service: string;
  status: 'healthy' | 'unhealthy' | 'degraded';
  responseTime: number;
  details?: string;
}

export async function GET() {
  const checks: HealthCheck[] = [];
  const startTime = Date.now();

  // ë°ì´í„°ë² ì´ìŠ¤ í—¬ìŠ¤ ì²´í¬
  try {
    const dbStart = Date.now();
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );
    
    await supabase.from('users').select('count').limit(1);
    
    checks.push({
      service: 'database',
      status: 'healthy',
      responseTime: Date.now() - dbStart
    });
  } catch (error) {
    checks.push({
      service: 'database',
      status: 'unhealthy',
      responseTime: Date.now() - startTime,
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }

  // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì²´í¬
  const memoryUsage = process.memoryUsage();
  const memoryStatus = memoryUsage.heapUsed / memoryUsage.heapTotal > 0.9 
    ? 'degraded' 
    : 'healthy';

  checks.push({
    service: 'memory',
    status: memoryStatus,
    responseTime: 0,
    details: `Heap: ${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB / ${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`
  });

  // ì „ì²´ ìƒíƒœ ê²°ì •
  const overallStatus = checks.every(c => c.status === 'healthy') 
    ? 'healthy'
    : checks.some(c => c.status === 'unhealthy')
    ? 'unhealthy'
    : 'degraded';

  const response = {
    status: overallStatus,
    timestamp: new Date().toISOString(),
    responseTime: Date.now() - startTime,
    checks,
    version: process.env.npm_package_version || '1.0.0'
  };

  const statusCode = overallStatus === 'healthy' ? 200 : 503;
  
  return NextResponse.json(response, { status: statusCode });
}
```

### 4.3 ë©”íŠ¸ë¦­ API

```typescript
// src/app/api/metrics/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { metrics } from '@/lib/metrics';
import { withAuth } from '@/lib/middleware/auth';

export const GET = withAuth(async (req: NextRequest) => {
  const { searchParams } = new URL(req.url);
  const metricName = searchParams.get('name');
  const since = searchParams.get('since');
  const sinceTimestamp = since ? parseInt(since) : Date.now() - 3600000; // 1ì‹œê°„ ì „

  if (metricName) {
    // íŠ¹ì • ë©”íŠ¸ë¦­ í†µê³„
    const stats = metrics.getStats(metricName, sinceTimestamp);
    return NextResponse.json({
      metric: metricName,
      period: {
        since: new Date(sinceTimestamp).toISOString(),
        until: new Date().toISOString()
      },
      stats
    });
  } else {
    // ëª¨ë“  ë©”íŠ¸ë¦­ ëª©ë¡
    const allMetrics = metrics.getMetrics(undefined, sinceTimestamp);
    const metricNames = [...new Set(allMetrics.map(m => m.name))];
    
    const summary = metricNames.map(name => ({
      name,
      stats: metrics.getStats(name, sinceTimestamp)
    }));

    return NextResponse.json({
      period: {
        since: new Date(sinceTimestamp).toISOString(),
        until: new Date().toISOString()
      },
      metrics: summary
    });
  }
}, ['admin']);
```

---

## ğŸš¨ 5. ì•Œë¦¼ ì‹œìŠ¤í…œ

### 5.1 ì•Œë¦¼ ë§¤ë‹ˆì €

```typescript
// src/lib/alerting.ts
export interface Alert {
  id: string;
  level: 'info' | 'warning' | 'error' | 'critical';
  title: string;
  message: string;
  timestamp: number;
  source: string;
  metadata?: Record<string, any>;
}

export class AlertManager {
  private static instance: AlertManager;
  private alerts: Alert[] = [];
  private webhookUrl?: string;

  constructor() {
    this.webhookUrl = process.env.ALERT_WEBHOOK_URL;
  }

  static getInstance(): AlertManager {
    if (!AlertManager.instance) {
      AlertManager.instance = new AlertManager();
    }
    return AlertManager.instance;
  }

  // ì•Œë¦¼ ìƒì„±
  async createAlert(
    level: Alert['level'],
    title: string,
    message: string,
    source: string,
    metadata?: Record<string, any>
  ): Promise<void> {
    const alert: Alert = {
      id: crypto.randomUUID(),
      level,
      title,
      message,
      timestamp: Date.now(),
      source,
      metadata
    };

    this.alerts.push(alert);

    // ë¡œê·¸ ê¸°ë¡
    logger.warn('Alert Created', {
      alert: {
        id: alert.id,
        level: alert.level,
        title: alert.title,
        source: alert.source
      }
    });

    // ì›¹í›… ì „ì†¡ (critical ë˜ëŠ” error ë ˆë²¨)
    if ((level === 'critical' || level === 'error') && this.webhookUrl) {
      await this.sendWebhook(alert);
    }
  }

  // ì›¹í›… ì „ì†¡
  private async sendWebhook(alert: Alert): Promise<void> {
    if (!this.webhookUrl) return;

    try {
      await fetch(this.webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          text: `ğŸš¨ ${alert.level.toUpperCase()}: ${alert.title}`,
          attachments: [
            {
              color: alert.level === 'critical' ? 'danger' : 'warning',
              fields: [
                {
                  title: 'Message',
                  value: alert.message,
                  short: false
                },
                {
                  title: 'Source',
                  value: alert.source,
                  short: true
                },
                {
                  title: 'Time',
                  value: new Date(alert.timestamp).toISOString(),
                  short: true
                }
              ]
            }
          ]
        })
      });
    } catch (error) {
      logger.error('Failed to send webhook alert', error as Error, {
        alertId: alert.id
      });
    }
  }

  // ì•Œë¦¼ ì¡°íšŒ
  getAlerts(level?: Alert['level'], since?: number): Alert[] {
    let filtered = this.alerts;

    if (level) {
      filtered = filtered.filter(a => a.level === level);
    }

    if (since) {
      filtered = filtered.filter(a => a.timestamp >= since);
    }

    return filtered.sort((a, b) => b.timestamp - a.timestamp);
  }
}

// ì „ì—­ ì•Œë¦¼ ë§¤ë‹ˆì €
export const alertManager = AlertManager.getInstance();
```

### 5.2 ìë™ ì•Œë¦¼ ê·œì¹™

```typescript
// src/lib/alertRules.ts
import { alertManager } from './alerting';
import { metrics } from './metrics';

export class AlertRules {
  private static checkInterval = 60000; // 1ë¶„ë§ˆë‹¤ ì²´í¬

  static startMonitoring(): void {
    setInterval(() => {
      this.checkErrorRate();
      this.checkResponseTime();
      this.checkMemoryUsage();
      this.checkTradeVolume();
    }, this.checkInterval);
  }

  // ì—ëŸ¬ìœ¨ ì²´í¬
  private static checkErrorRate(): void {
    const since = Date.now() - 300000; // 5ë¶„ ì „
    const errorMetrics = metrics.getMetrics('api.error', since);
    const totalMetrics = metrics.getMetrics('api.request', since);

    if (totalMetrics.length > 0) {
      const errorRate = errorMetrics.length / totalMetrics.length;
      
      if (errorRate > 0.1) { // 10% ì´ìƒ ì—ëŸ¬ìœ¨
        alertManager.createAlert(
          'error',
          'High Error Rate Detected',
          `Error rate is ${(errorRate * 100).toFixed(2)}% over the last 5 minutes`,
          'error_rate_monitor',
          { errorRate, errorCount: errorMetrics.length, totalCount: totalMetrics.length }
        );
      }
    }
  }

  // ì‘ë‹µ ì‹œê°„ ì²´í¬
  private static checkResponseTime(): void {
    const since = Date.now() - 300000; // 5ë¶„ ì „
    const stats = metrics.getStats('api.response_time', since);

    if (stats.count > 0 && stats.avg > 2000) { // í‰ê·  2ì´ˆ ì´ìƒ
      alertManager.createAlert(
        'warning',
        'Slow Response Time',
        `Average response time is ${stats.avg.toFixed(0)}ms over the last 5 minutes`,
        'response_time_monitor',
        { averageResponseTime: stats.avg, maxResponseTime: stats.max }
      );
    }
  }

  // ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì²´í¬
  private static checkMemoryUsage(): void {
    const memoryUsage = process.memoryUsage();
    const heapUsagePercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100;

    if (heapUsagePercent > 90) {
      alertManager.createAlert(
        'critical',
        'High Memory Usage',
        `Heap usage is ${heapUsagePercent.toFixed(1)}%`,
        'memory_monitor',
        { heapUsed: memoryUsage.heapUsed, heapTotal: memoryUsage.heapTotal }
      );
    }
  }

  // ê±°ë˜ëŸ‰ ì²´í¬
  private static checkTradeVolume(): void {
    const since = Date.now() - 3600000; // 1ì‹œê°„ ì „
    const tradeStats = metrics.getStats('trade.created', since);

    if (tradeStats.count === 0) {
      alertManager.createAlert(
        'warning',
        'No Trades in Last Hour',
        'No trades have been created in the last hour',
        'trade_volume_monitor',
        { period: '1 hour' }
      );
    }
  }
}
```

---

## ğŸ“± 6. ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ UI

### 6.1 ê´€ë¦¬ì ëª¨ë‹ˆí„°ë§ í˜ì´ì§€

```typescript
// src/app/admin/monitoring/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

interface SystemHealth {
  status: 'healthy' | 'unhealthy' | 'degraded';
  checks: Array<{
    service: string;
    status: string;
    responseTime: number;
    details?: string;
  }>;
}

export default function MonitoringPage() {
  const [health, setHealth] = useState<SystemHealth | null>(null);
  const [metrics, setMetrics] = useState<any>(null);
  const [alerts, setAlerts] = useState<any[]>([]);

  useEffect(() => {
    const fetchData = async () => {
      try {
        // í—¬ìŠ¤ ì²´í¬
        const healthRes = await fetch('/api/health');
        const healthData = await healthRes.json();
        setHealth(healthData);

        // ë©”íŠ¸ë¦­
        const metricsRes = await fetch('/api/metrics');
        const metricsData = await metricsRes.json();
        setMetrics(metricsData);

        // ì•Œë¦¼
        const alertsRes = await fetch('/api/alerts');
        const alertsData = await alertsRes.json();
        setAlerts(alertsData);
      } catch (error) {
        console.error('Failed to fetch monitoring data:', error);
      }
    };

    fetchData();
    const interval = setInterval(fetchData, 30000); // 30ì´ˆë§ˆë‹¤ ê°±ì‹ 

    return () => clearInterval(interval);
  }, []);

  return (
    <div className="space-y-6">
      <h1 className="text-3xl font-bold">ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§</h1>

      {/* ì‹œìŠ¤í…œ ìƒíƒœ */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <Card>
          <CardHeader>
            <CardTitle>ì‹œìŠ¤í…œ ìƒíƒœ</CardTitle>
          </CardHeader>
          <CardContent>
            <div className={`text-2xl font-bold ${
              health?.status === 'healthy' ? 'text-green-600' :
              health?.status === 'degraded' ? 'text-yellow-600' :
              'text-red-600'
            }`}>
              {health?.status?.toUpperCase() || 'LOADING...'}
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>í™œì„± ì•Œë¦¼</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {alerts.filter(a => a.level === 'error' || a.level === 'critical').length}
            </div>
            <p className="text-sm text-gray-600">ì¤‘ìš” ì•Œë¦¼</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>ì‘ë‹µ ì‹œê°„</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {health?.responseTime || 0}ms
            </div>
            <p className="text-sm text-gray-600">í‰ê·  ì‘ë‹µ ì‹œê°„</p>
          </CardContent>
        </Card>
      </div>

      {/* ì„œë¹„ìŠ¤ ìƒíƒœ */}
      <Card>
        <CardHeader>
          <CardTitle>ì„œë¹„ìŠ¤ ìƒíƒœ</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {health?.checks.map((check, index) => (
              <div key={index} className="flex items-center justify-between p-3 border rounded">
                <div>
                  <h3 className="font-medium">{check.service}</h3>
                  {check.details && (
                    <p className="text-sm text-gray-600">{check.details}</p>
                  )}
                </div>
                <div className="text-right">
                  <div className={`font-medium ${
                    check.status === 'healthy' ? 'text-green-600' :
                    check.status === 'degraded' ? 'text-yellow-600' :
                    'text-red-600'
                  }`}>
                    {check.status}
                  </div>
                  <div className="text-sm text-gray-600">
                    {check.responseTime}ms
                  </div>
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* ìµœê·¼ ì•Œë¦¼ */}
      <Card>
        <CardHeader>
          <CardTitle>ìµœê·¼ ì•Œë¦¼</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-3">
            {alerts.slice(0, 10).map((alert, index) => (
              <div key={index} className={`p-3 border-l-4 ${
                alert.level === 'critical' ? 'border-red-500 bg-red-50' :
                alert.level === 'error' ? 'border-red-400 bg-red-50' :
                alert.level === 'warning' ? 'border-yellow-400 bg-yellow-50' :
                'border-blue-400 bg-blue-50'
              }`}>
                <div className="flex justify-between items-start">
                  <div>
                    <h4 className="font-medium">{alert.title}</h4>
                    <p className="text-sm text-gray-600">{alert.message}</p>
                  </div>
                  <div className="text-xs text-gray-500">
                    {new Date(alert.timestamp).toLocaleString()}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

---

## ğŸ”§ 7. ìš´ì˜ ê°€ì´ë“œ

### 7.1 ì¼ì¼ ëª¨ë‹ˆí„°ë§ ì²´í¬ë¦¬ìŠ¤íŠ¸

```markdown
## ğŸ“‹ ì¼ì¼ ëª¨ë‹ˆí„°ë§ ì²´í¬ë¦¬ìŠ¤íŠ¸

### ğŸŒ… ì˜¤ì „ ì²´í¬ (09:00)
- [ ] ì‹œìŠ¤í…œ ì „ì²´ ìƒíƒœ í™•ì¸ (/api/health)
- [ ] ë°¤ì‚¬ì´ ë°œìƒí•œ ì—ëŸ¬ ë¡œê·¸ ê²€í† 
- [ ] ì¤‘ìš” ì•Œë¦¼ í™•ì¸ ë° ì²˜ë¦¬
- [ ] ë°ì´í„°ë² ì´ìŠ¤ ì„±ëŠ¥ ë©”íŠ¸ë¦­ í™•ì¸
- [ ] ì‚¬ìš©ì í™œë™ ì§€í‘œ í™•ì¸

### ğŸŒ† ì˜¤í›„ ì²´í¬ (15:00)
- [ ] í”¼í¬ ì‹œê°„ëŒ€ ì„±ëŠ¥ í™•ì¸
- [ ] ê±°ë˜ëŸ‰ ë° ì‚¬ìš©ì í™œë™ ëª¨ë‹ˆí„°ë§
- [ ] ì—ëŸ¬ìœ¨ ë° ì‘ë‹µ ì‹œê°„ í™•ì¸
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í™•ì¸

### ğŸŒ™ ì €ë… ì²´í¬ (21:00)
- [ ] í•˜ë£¨ ì „ì²´ í†µê³„ ë¦¬ë·°
- [ ] ë°±ì—… ìƒíƒœ í™•ì¸
- [ ] ë‹¤ìŒë‚  ì˜ˆìƒ ì´ìŠˆ ê²€í† 
- [ ] ì•Œë¦¼ ê·œì¹™ íš¨ê³¼ì„± ê²€í† 
```

### 7.2 ì£¼ê°„ ëª¨ë‹ˆí„°ë§ ë¦¬í¬íŠ¸

```typescript
// src/lib/weeklyReport.ts
export class WeeklyReportGenerator {
  static async generateReport(): Promise<{
    period: { start: string; end: string };
    summary: {
      totalUsers: number;
      totalTrades: number;
      averageResponseTime: number;
      errorRate: number;
      uptime: number;
    };
    trends: {
      userGrowth: number;
      tradeGrowth: number;
      performanceChange: number;
    };
    issues: Array<{
      date: string;
      issue: string;
      impact: string;
      resolution: string;
    }>;
  }> {
    const endDate = new Date();
    const startDate = new Date(endDate.getTime() - 7 * 24 * 60 * 60 * 1000);

    // ë°ì´í„° ìˆ˜ì§‘ ë° ë¶„ì„ ë¡œì§
    // ...

    return {
      period: {
        start: startDate.toISOString(),
        end: endDate.toISOString()
      },
      summary: {
        totalUsers: 0, // ì‹¤ì œ ë°ì´í„°ë¡œ êµì²´
        totalTrades: 0,
        averageResponseTime: 0,
        errorRate: 0,
        uptime: 99.9
      },
      trends: {
        userGrowth: 0,
        tradeGrowth: 0,
        performanceChange: 0
      },
      issues: []
    };
  }
}
```

### 7.3 ì¥ì•  ëŒ€ì‘ ì ˆì°¨

```markdown
## ğŸš¨ ì¥ì•  ëŒ€ì‘ ì ˆì°¨

### 1ë‹¨ê³„: ì¥ì•  ê°ì§€ (0-5ë¶„)
1. ìë™ ì•Œë¦¼ ìˆ˜ì‹  í™•ì¸
2. ì‹œìŠ¤í…œ ìƒíƒœ ëŒ€ì‹œë³´ë“œ í™•ì¸
3. ì¥ì•  ë²”ìœ„ ë° ì˜í–¥ë„ íŒŒì•…
4. ì´ˆê¸° ëŒ€ì‘íŒ€ ì†Œì§‘

### 2ë‹¨ê³„: ì´ˆê¸° ëŒ€ì‘ (5-15ë¶„)
1. ì¥ì•  ì›ì¸ ë¶„ì„ ì‹œì‘
2. ì„ì‹œ ì¡°ì¹˜ ë°©ì•ˆ ê²€í† 
3. ì‚¬ìš©ì ê³µì§€ì‚¬í•­ ì¤€ë¹„
4. ì—ìŠ¤ì»¬ë ˆì´ì…˜ í•„ìš”ì„± íŒë‹¨

### 3ë‹¨ê³„: ë³µêµ¬ ì‘ì—… (15ë¶„-1ì‹œê°„)
1. ë³µêµ¬ ê³„íš ìˆ˜ë¦½ ë° ì‹¤í–‰
2. ì§„í–‰ ìƒí™© ëª¨ë‹ˆí„°ë§
3. ì‚¬ìš©ì ì»¤ë®¤ë‹ˆì¼€ì´ì…˜
4. ë³µêµ¬ ì™„ë£Œ í™•ì¸

### 4ë‹¨ê³„: ì‚¬í›„ ë¶„ì„ (1-24ì‹œê°„)
1. ì¥ì•  ì›ì¸ ìƒì„¸ ë¶„ì„
2. ì¬ë°œ ë°©ì§€ ëŒ€ì±… ìˆ˜ë¦½
3. í”„ë¡œì„¸ìŠ¤ ê°œì„  ë°©ì•ˆ ë„ì¶œ
4. ì‚¬í›„ ë³´ê³ ì„œ ì‘ì„±
```

ì´ ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹… ì‹œìŠ¤í…œì„ í†µí•´ QuantTrade í”Œë«í¼ì˜ ì•ˆì •ì ì¸ ìš´ì˜ê³¼ ì§€ì†ì ì¸ ê°œì„ ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. 